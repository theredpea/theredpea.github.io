<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - loaders - OBJ loader</title>
    <meta charset="utf-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css"
          rel="stylesheet"
          href="main.css">
</head>

<body>
    <div id="info">
        <a href="https://threejs.org"
           target="_blank"
           rel="noopener">three.js</a> - OBJLoader test
    </div>

    <script type="module">

        // import * as THREE from '../build/three.module.js';
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r123/three.module.js';

        // https://stackoverflow.com/a/18049842/1175496
        // import { OBJLoader } from 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/js/loaders/OBJLoader.js';

        // import { OBJLoader } from 'https://cdn.jsdelivr.net/gh/mrdoob/three.js/examples/js/loaders/OBJLoader.js';
        import { OBJLoader } from 'https://cdn.jsdelivr.net/gh/mrdoob/three.js/examples/jsm/loaders/OBJLoader.js';
        import { MTLLoader } from 'https://cdn.jsdelivr.net/gh/mrdoob/three.js/examples/jsm/loaders/MTLLoader.js';
        // https://github.com/mrdoob/three.js/tree/master/examples/jsm/loaders
        let container;

        let camera, scene, renderer;

        let mouseX = 0, mouseY = 0;

        let windowHalfX = window.innerWidth / 2;
        let windowHalfY = window.innerHeight / 2;

        let object;

        const threshholdX = 10;
        const threshholdY = threshholdX;

        init();
        animate();


        function init() {

            container = document.createElement('div');
            document.body.appendChild(container);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
            camera.position.z = 10;

            // scene

            scene = new THREE.Scene();

            const ambientLight = new THREE.AmbientLight(0xcccccc, 0.4);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 0.8);
            camera.add(pointLight);
            scene.add(camera);

            // manager

            function loadModel() {

                object.traverse(function (child) {

                    // if (child.isMesh) child.material.map = texture;

                });

                // object.position.y = - 95;
                scene.add(object);

            }

            const manager = new THREE.LoadingManager(loadModel);

            manager.onProgress = function (item, loaded, total) {

                console.log(item, loaded, total);

            };

            // texture

            const textureLoader = new THREE.TextureLoader(manager);
            const texture = textureLoader.load('textures/uv_grid_opengl.jpg');

            // model

            function onProgress(xhr) {

                if (xhr.lengthComputable) {

                    const percentComplete = xhr.loaded / xhr.total * 100;
                    console.log('model ' + Math.round(percentComplete, 2) + '% downloaded');

                }

            }

            function onError() { }


            const loader = new OBJLoader(manager);

            //

            const materialsLoader = new MTLLoader(manager);

            materialsLoader.load('models/obj/Modeling Water Polo for Export.obj/d2e8bc61-6dd1-4554-b874-13b5364d656e.mtl', function (materialsCreator) {

                // https://threejs.org/docs/#examples/en/loaders/OBJLoader.setMaterials
                loader.setMaterials(materialsCreator);


                // loader.load( 'models/obj/male02/male02.obj', function ( obj ) {
                loader.load('models/obj/Modeling Water Polo for Export.obj/d2e8bc61-6dd1-4554-b874-13b5364d656e.obj', function (obj) {

                    object = obj;

                }, onProgress, onError);

            }, onProgress, onError);

            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            document.addEventListener('mousemove', onDocumentMouseMove, false);

            //

            window.addEventListener('resize', onWindowResize, false);

        }

        function onWindowResize() {

            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        function onDocumentMouseMove(event) {

            mouseX = (event.clientX - windowHalfX) / 2;
            mouseY = (event.clientY - windowHalfY) / 2;

        }

        //

        function animate() {

            requestAnimationFrame(animate);
            render();

        }

        function render() {
            /// TODO Don't let camera x / y position drift too far , clamp it to min/max
            camera.position.x += (mouseX - camera.position.x) * .05 / 5;
            camera.position.y += (- mouseY - camera.position.y) * .05 / 5;

            console.log(camera.position.x, camera.position.y);
            if (Math.abs(camera.position.x) > threshholdX) {
                camera.position.x = threshholdX * Math.abs(camera.position.x) / camera.position.x;
            }
            if (Math.abs(camera.position.y) > threshholdY) {
                camera.position.y = threshholdY * Math.abs(camera.position.y) / camera.position.y;
            }

            camera.lookAt(scene.position);

            renderer.render(scene, camera);

        }

    </script>

</body>

</html>